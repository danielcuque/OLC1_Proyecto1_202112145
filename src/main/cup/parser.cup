package com.daniel;

import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.List;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import com.daniel.controller.Tree.*;
import com.daniel.controller.Conjunto.*;
import com.daniel.controller.*;

parser code {:

    public int operatorNodeCounter;
    public int nodeCounter;

    public ArrayList<Conjunto> Conjuntos = new ArrayList<Conjunto>();
    public ArrayList<Tree> Trees = new ArrayList<Tree>();
    public ArrayList<String> CheckStrings = new ArrayList<String>();


    // Lista de errores
    public ArrayList<ExceptionReport> Errors = new ArrayList<ExceptionReport>();

    public void syntax_error(Symbol s){
        Errors.add(new ExceptionReport("Sintactico", "Error de sintaxis detectado. Se detecto: " + s.value, s.left + "", s.right + ""));
        }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
            System.out.println("Error sintactico irrecuperable en la Línea " + (s.left)+ " Columna "+s.right+". Componente " + s.value + " no reconocido.");
            }
            public ArrayList<ExceptionReport> getErrores(){
                return Errors;
            }
:}


terminal String CONJ, LBRACE, RBRACE, COLON, BODY_ARROW, HEAD_ARROW, PERCENT, DOT, STAR, PLUS;
terminal String QUERY, PIPE, TILDE;
terminal String COMMA, SEMICOLON, ESCAPE_SEQUENCE;
terminal String LOWERCASE, UPPERCASE, IDENTIFIER, DIGIT, STRING_LITERAL,ASCII;

non terminal Begin, BodyEntry;
non terminal ConjBody, ConjDef;
non terminal String ConjNotation;
non terminal String RangeExp;
non terminal String IndExp, MoreIndExp;
non terminal String UnitSymbol;
non terminal CheckBody, CheckLine;

non terminal ExpBody, ExpLine;
non terminal Node RegExp;

start with Begin;

// Definimos la sección para la declaración de la gramática
Begin ::=LBRACE BodyEntry RBRACE;

BodyEntry ::= ConjBody ExpBody PERCENT CheckBody;

// Definimos la sección para los conjuntos de regex
ConjBody ::= ConjDef ConjBody | ConjDef;

ConjDef ::= CONJ COLON IDENTIFIER:id BODY_ARROW HEAD_ARROW ConjNotation:notation SEMICOLON {:
    System.out.println("Conjunto: " + id + " Notacion: " + notation);
:};

ConjNotation ::= RangeExp:range {:
RESULT = range;
:}
|IndExp:ind {:
RESULT = ind;
:};

RangeExp ::= LOWERCASE:l1 TILDE LOWERCASE:l2 {:
RESULT = l1 + "~" + l2;

:}
| UPPERCASE:u1 TILDE UPPERCASE:u2 {:
RESULT = u1 + "~" + u2;
:}
| DIGIT:d1 TILDE DIGIT:d2 {:

RESULT = d1 + "~" + d2;
:}
| ASCII:a1 TILDE ASCII:a2 {:
RESULT = a1 + "~" + a2;
:};

IndExp ::=  UnitSymbol:u MoreIndExp:m {:
RESULT = u + m;
:} | UnitSymbol:u {:
RESULT = u;
:};

MoreIndExp ::= COMMA:c UnitSymbol:u MoreIndExp:m {:
RESULT = c + u + m;
:} | COMMA:c UnitSymbol:u {:
RESULT = c + u;
:};

UnitSymbol ::= LOWERCASE:l {:
RESULT = l;
:} | UPPERCASE:u {: RESULT = u; :}  | DIGIT:d {: RESULT = d; :} | ASCII:a {: RESULT = a; :};

// Definimos la sección para la asignación de expresiones regulares a conjuntos
ExpBody ::= ExpLine ExpBody | ExpLine ;

ExpLine ::= IDENTIFIER:id BODY_ARROW HEAD_ARROW RegExp:val SEMICOLON {:
    Trees.add(new Tree(val, id, operatorNodeCounter, nodeCounter));
    operatorNodeCounter = 0;
    nodeCounter = 0;
:};

RegExp ::= PIPE RegExp:pipe1 RegExp:pipe2 {:
    operatorNodeCounter++;
    RESULT = new Node("|",NodeType.OR, operatorNodeCounter,pipe1, pipe2);
:}
| DOT RegExp:dot1 RegExp:dot2 {:
operatorNodeCounter++;
RESULT = new Node(".",NodeType.AND, operatorNodeCounter,dot1, dot2);
:}
| PLUS RegExp:plus {:
operatorNodeCounter++;
RESULT = new Node("+",NodeType.PLUS, operatorNodeCounter,plus);
:}
| STAR RegExp:star {:
operatorNodeCounter++;
RESULT = new Node("*",NodeType.STAR, operatorNodeCounter,star);
:}
| QUERY RegExp:query {:
operatorNodeCounter++;
RESULT = new Node("?",NodeType.QUERY, operatorNodeCounter,query);
:}
| LBRACE IDENTIFIER:id RBRACE {:
nodeCounter++;
RESULT = new Node(id, NodeType.LEAVE, nodeCounter);
:} | STRING_LITERAL:val {:
nodeCounter++;
RESULT = new Node(val, NodeType.LEAVE, nodeCounter);
:} | ESCAPE_SEQUENCE:val {:
nodeCounter++;
RESULT = new Node(val, NodeType.LEAVE, nodeCounter);
:};

// Definimos la sección para las cadenas a evaluar
CheckBody ::= CheckLine CheckBody | CheckLine;

CheckLine ::= IDENTIFIER COLON STRING_LITERAL SEMICOLON;



